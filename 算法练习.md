# 链表反转

**源码：**/cpp_pro/linked_list/  reverse_iterate()

# 合并两个有序链表

**源码：**/cpp_pro/linked_list/  merge_sorted_linked_list()

# 合并两个有序数组

**方法三思路关键点**：

- 每个数组都是有序的，因此比较后每个数组都是从后往前==依次==移动元素的，所以不会存在数组1中的元素被覆盖的情况(因为极端情况就是数组2都移动到数组1后面了，数组1的元素还没移动过)。
- 代码中注意每次移动了元素的数组下标才递减，没有元素移动的数组下表则不变：

```c
// 错误示例
for (int i = n - 1, j = m - 1; i >= 0 && j >= 0; i--,j--) {// 每次移动元素，两个数组的下标都递减，错误！！！
    if (i >= 0 && j >= 0) {// array1 and array2 have element to compare and move
        if (array1[i] >= array2[j]) {
            array1[--sum] = array1[i];
            
        } else {
            array1[--sum] = array2[j];
            
        }
    } else if (i >= 0) {// just remain array1 element to move
        array1[--sum] = array1[i];
        
    } else if (j >= 0) {// just remain array2 element to move
        array1[--sum] = array2[j];
        
    }
}

// 正确示例
for (int i = n - 1, j = m - 1; i >= 0 && j >= 0;) {
    if (i >= 0 && j >= 0) {// array1 and array2 have element to compare and move
        if (array1[i] >= array2[j]) {
            array1[--sum] = array1[i];
            i--;// 每次只有移动了元素的数组下标递减
        } else {
            array1[--sum] = array2[j];
            j--;// 每次只有移动了元素的数组下标递减
        }
    } else if (i >= 0) {// just remain array1 element to move
        array1[--sum] = array1[i];
        i--;// 每次只有移动了元素的数组下标递减
    } else if (j >= 0) {// just remain array2 element to move
        array1[--sum] = array2[j];
        j--;// 每次只有移动了元素的数组下标递减
    }
}
```

**源码：**/cpp_pro/array/  mergeSortedArray()

# 寻找链表中间节点

**方法三思路关键点：**

- 列表至少需要遍历一次，这一步是无论如何也避免不了的。
- 那思考可否在遍历一次就能找到中间点，这里巧妙地利用==双指针==，并根据每次==步长==的关系(1:2)，在一次遍历中就找到中间节点。拓展思考，有的场景可以利用多指针，调整步比例来解决其他问题。
- 注意结束条件，由于快指针步长为2(主要考虑列表元素长度对2取模的余数)，所以结束条件应该是2中情况。或者从如下的快指针的赋值语句来判定：首先确保p_two_step != nullptr，然后再确定p_two_step->next !=nullptr。

```c
// 此处要使用p_two_step来取值，所以首先应保证p_two_step不为空，因此应保持如下代码的&语句的顺序
while (p_two_step != nullptr && p_two_step->next != nullptr) {
	p_one_step = p_one_step->next;
	p_two_step = p_two_step->next->next;
}
```

**源码：**/cpp_pro/linked_list/  find_mid_node()

**关键词语：**==循环、步长==

# 三个数之和

**思路关键点：**

难点在于如何去除重复解

**算法流程：**

- 边界条件，数组长度为len，如果数组为null或者数组长度小于3，直接返回空。

- 对数组做升序排序

- 第一重循环开始遍历数组：

  - 若num[i] > 0，直接返回结果。因为数组已经排序过，从i开始后续再无可能三数之和等于0；
  - 对于重复元素，考虑三个位置：第一数、第二个数和第三个数。这三个位置遇到重复元素都直接跳过，只需使用一次重复元素即可

  ```java
  // 第一个位置元素重复
  if (i > 0 && inNums[i] == inNums[i - 1]) {
  	continue
  }
  
  // 第二个位置元素重复
  while (pL < pR && inNums[pL + 1] == inNums[pL]) {
  	pL++;
  }
  
  // 第三个位置元素重复
  while (pL < pR && inNums[pR - 1] == inNums[pR]) {
  	pR--;
  }
  ```

  - 这是一个有顺序的问题，可以使用双指针加快查找。假设指向第二个元素的位置为左指针L = i +1，指向第三个元素的位置为右边指针R = len -1，开启第二重循环；
    - 当num[i] + num[L] + num[R] = 0，找到一组结果。继续执行判断左界和右界是否和他们的下一位置重复。如果重复则跳过直到不重复。但L和R没有重复时，同时将L，R 移到下一位置，寻找新的解。
    - 若num[i] + num[L] + num[R] > 0，说明 num[R]太大，只需R左移；
    - 若num[i] + num[L] + num[R] < 0，说明 num[L]太小，只需L右移；

**源码：**/java_pro/  threeSum()

**关键字：**排序，==双指针==，==重复跳过==

# 寻找众数

**投票方法思路理解：**

- 如果候选人不是major，则真正的major会和其他非候选人一起反对当前候选人(count减少)，那么当前候选人最终一定会下台(count==0时发生换届选举)；
- 如果候选人是major , 则major会支持自己(count增加)，虽然其他候选人会反对，但因为major票数超过一半，所以最终major一定会成功当选。即最终candidate一定是major。

```c
if (count == 0) {// 候选人换届
	candidate = num;
}
/**
* 候选人被支持(num == candidate)，count增加
* 候选人被反对(num != candidate),count减少
**/
count += (num == candidate) ? 1 : -1;
```

**源码：**/cpp_pro/array/   majorElement2()

**关键词：**==投票==，==支持/反对==，==换届==

# 缺失的第一个正整数

**思路理解：**

- 明白第一个正整数x的特性，x一定落在[1,n+1]之间。
- 利用现有数组空间，稍加改造成hashmap，方便快速查找。
- 既要标记位置，又要保留位置上的数值，因此这里采用改变符号来实现。

**源码：**/java_pro/  firstMissingPositive()

**关键词：**数组改造hashmap、改变符号来标记、排除负数影响

# 链表是否有环

**快慢指针思路理解：**

- 有环快慢指针一定相遇；
- 初始条件slow = head，fast = head->nex，可以理解为在head之前有一个虚拟节点，且初始条件是两个节点分别按照自己的步长走了一次;
- 注意快指针的非空判定；

```c
if (fast == nullptr || fast->next == nullptr) {
    return false;
}
```

- 快指针每移动一步，就可以判定是否与满指针相遇，这样便于快速判定是否有环。

```c
slow = slow->next;
fast = fast->next;
if (fast != nullptr && slow == fast) {
    return true;
}
```

**源码：**/cpp_pro/linked_list/   has_circle()

**关键字：**==快慢指针==

# 合并k个排序链表

**思路关键：**

- 方法都依赖于合并两个有序链表
- 方法二的递归，注意结束条件：

```c
if (left == right) return lists[left];
if (left > right) return nullptr;
```

**源码：**/cpp_pro/linked_list/  merge_k_sorted_linked_list_1()/merge_k_sorted_linked_list_2()

**关键词：**两个有序链表合并、两两合并逐步减少量

# 数组实现栈

**核心要点：**

- ==索引0作为栈底==
- ==栈顶top指向的是待入栈的位置==
- 空栈：top = 0
- 满栈：top = size

# 链表实现栈

**核心要点：**

- 链表头作为栈底，==链表尾部作为栈顶，栈顶top指向栈顶元素，且需要确保栈底元素的next指针为nullptr==
- 没有满栈之说，只有空栈问题
- 空栈：top = nullptr

# 数组实现队列

**核心要点：**

- ==索引0作为对头==
- ==对头索引head指向对头元素，队尾索引tail指向的是下一个待入队的位置==
- 空队：head == tail
- 满队：tail == size && head == 0
- 只有当tail == size，再触发是否需要移动队列前部分的元素：

```c
if (tail == size) {
    ……
    /**
     * move array's valid element to head only when tail grow up to size
     */
    for (int i = head; i < tail; ++i) {
        items[i - head] = item[i];
    }
    tail -= head;
    head = 0;
}
```

# 链表实现队列

核心要点：

- ==链表头作为对头，链表尾作为队尾==

- ==head指向对头元素，tail指向队尾元素==

- 没有满对之说，只有空队问题

- 队空：head == nullptr

- 入队：

  - 首先将待入队元素的next指向nullptr

  - 如果head == nullptr，表示此时队空，对头head和队尾tail都指向入队元素

  - 否则只需要把当前队尾元素的next指向待入队元素，并移动队尾

    ```c
    // 先将待入队元素的next指向nullptr
    item->next = nullptr;
    if (head == nullptr) {// 队列为空
        head = item;
        tail = item;
        return true;
    }
    // 队列不为空，正常入队
    tail->next = item;
    tail = item;
    return true;
    ```

- 出队：

  - 如果队列为空，直接返回nullptr
  - 否则正常将head指向的元素返回（注意在返回之前，将该元素的next指向nullptr），并将head指针后移一位(此时可以检查移动后的head是否为空，如果为空表示队列已经空，可以顺带将tail = nullptr)

  ```c
  linked_list::node<T> *LinkedListQueue<T>::dequeue() {
    	// 先判定队列是否为空
      if (head == nullptr) {
          return nullptr;
      }
    	// 不为空正常出队
      linked_list::node<T> *item = head;
      head = head->next;
      if (head == nullptr) {// 出队后再看看队列是否已经为空
          tail = nullptr;
      }
    	// 返回之前一定要记得把next指向nullptr,切断连接
      item->next = nullptr;
      return item;
  }
  ```

  

