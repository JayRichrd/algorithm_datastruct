# 链表反转

源码：/cpp_pro/linked_list/  reverse_iterate()

# 合并两个有序链表

源码：/cpp_pro/linked_list/  merge_sorted_linked_list()

# 合并两个有序数组

**方法三思路关键点**：

- 每个数组都是有序的，因此比较后每个数组都是从后往前==依次==移动元素的，所以不会存在数组1中的元素被覆盖的情况(因为极端情况就是数组2都移动到数组1后面了，数组1的元素还没移动过)。
- 代码中注意每次移动了元素的数组下标才递减，没有元素移动的数组下表则不变：

```c
// 错误示例
for (int i = n - 1, j = m - 1; i >= 0 && j >= 0; i--,j--) {// 每次移动元素，两个数组的下标都递减，错误！！！
    if (i >= 0 && j >= 0) {// array1 and array2 have element to compare and move
        if (array1[i] >= array2[j]) {
            array1[--sum] = array1[i];
            
        } else {
            array1[--sum] = array2[j];
            
        }
    } else if (i >= 0) {// just remain array1 element to move
        array1[--sum] = array1[i];
        
    } else if (j >= 0) {// just remain array2 element to move
        array1[--sum] = array2[j];
        
    }
}

// 正确示例
for (int i = n - 1, j = m - 1; i >= 0 && j >= 0;) {
    if (i >= 0 && j >= 0) {// array1 and array2 have element to compare and move
        if (array1[i] >= array2[j]) {
            array1[--sum] = array1[i];
            i--;// 每次只有移动了元素的数组下标递减
        } else {
            array1[--sum] = array2[j];
            j--;// 每次只有移动了元素的数组下标递减
        }
    } else if (i >= 0) {// just remain array1 element to move
        array1[--sum] = array1[i];
        i--;// 每次只有移动了元素的数组下标递减
    } else if (j >= 0) {// just remain array2 element to move
        array1[--sum] = array2[j];
        j--;// 每次只有移动了元素的数组下标递减
    }
}
```

源码：/cpp_pro/array/  mergeSortedArray()

# 寻找链表中间节点

方法三思路关键点：

- 列表至少需要遍历一次，这一步是无论如何也避免不了的。
- 那思考可否在遍历一次就能找到中间点，这里巧妙地利用==双指针==，并根据每次步长的关系(1:2)，在一次遍历中就找到中间节点。拓展思考，有的场景可以利用多指针，调整步比例来解决其他问题。
- 注意结束条件，由于快指针步长为2(主要考虑列表元素长度对2取模的余数)，所以结束条件应该是2中情况。或者从如下的快指针的赋值语句来判定：首先确保p_two_step != nullptr，然后再确定p_two_step->next !=nullptr。

```c
// 此处要使用p_two_step来取值，所以首先应保证p_two_step不为空，因此应保持如下代码的&语句的顺序
while (p_two_step != nullptr && p_two_step->next != nullptr) {
	p_one_step = p_one_step->next;
	p_two_step = p_two_step->next->next;
}
```

源码：/cpp_pro/linked_list/  find_mid_node()