# 链表反转

**源码：**/cpp_pro/linked_list/  reverse_iterate()

# 合并两个有序链表

**源码：**/cpp_pro/linked_list/  merge_sorted_linked_list()

# 合并两个有序数组

**方法三思路关键点**：

- 每个数组都是有序的，因此比较后每个数组都是从后往前==依次==移动元素的，所以不会存在数组1中的元素被覆盖的情况(因为极端情况就是数组2都移动到数组1后面了，数组1的元素还没移动过)。
- 代码中注意每次移动了元素的数组下标才递减，没有元素移动的数组下表则不变：

```c
// 错误示例
for (int i = n - 1, j = m - 1; i >= 0 && j >= 0; i--,j--) {// 每次移动元素，两个数组的下标都递减，错误！！！
    if (i >= 0 && j >= 0) {// array1 and array2 have element to compare and move
        if (array1[i] >= array2[j]) {
            array1[--sum] = array1[i];
            
        } else {
            array1[--sum] = array2[j];
            
        }
    } else if (i >= 0) {// just remain array1 element to move
        array1[--sum] = array1[i];
        
    } else if (j >= 0) {// just remain array2 element to move
        array1[--sum] = array2[j];
        
    }
}

// 正确示例
for (int i = n - 1, j = m - 1; i >= 0 && j >= 0;) {
    if (i >= 0 && j >= 0) {// array1 and array2 have element to compare and move
        if (array1[i] >= array2[j]) {
            array1[--sum] = array1[i];
            i--;// 每次只有移动了元素的数组下标递减
        } else {
            array1[--sum] = array2[j];
            j--;// 每次只有移动了元素的数组下标递减
        }
    } else if (i >= 0) {// just remain array1 element to move
        array1[--sum] = array1[i];
        i--;// 每次只有移动了元素的数组下标递减
    } else if (j >= 0) {// just remain array2 element to move
        array1[--sum] = array2[j];
        j--;// 每次只有移动了元素的数组下标递减
    }
}
```

**源码：**/cpp_pro/array/  mergeSortedArray()

# 寻找链表中间节点

**方法三思路关键点：**

- 列表至少需要遍历一次，这一步是无论如何也避免不了的。
- 那思考可否在遍历一次就能找到中间点，这里巧妙地利用==双指针==，并根据每次==步长==的关系(1:2)，在一次遍历中就找到中间节点。拓展思考，有的场景可以利用多指针，调整步比例来解决其他问题。
- 注意结束条件，由于快指针步长为2(主要考虑列表元素长度对2取模的余数)，所以结束条件应该是2中情况。或者从如下的快指针的赋值语句来判定：首先确保p_two_step != nullptr，然后再确定p_two_step->next !=nullptr。

```c
// 此处要使用p_two_step来取值，所以首先应保证p_two_step不为空，因此应保持如下代码的&语句的顺序
while (p_two_step != nullptr && p_two_step->next != nullptr) {
	p_one_step = p_one_step->next;
	p_two_step = p_two_step->next->next;
}
```

**源码：**/cpp_pro/linked_list/  find_mid_node()

**关键词语：**==循环、步长==

# 三个数之和

**思路关键点：**

难点在于如何去除重复解

**算法流程：**

- 边界条件，数组长度为len，如果数组为null或者数组长度小于3，直接返回空。

- 对数组做升序排序

- 第一重循环开始遍历数组：

  - 若num[i] > 0，直接返回结果。因为数组已经排序过，从i开始后续再无可能三数之和等于0；
  - 对于重复元素，考虑三个位置：第一数、第二个数和第三个数。这三个位置遇到重复元素都直接跳过，只需使用一次重复元素即可

  ```java
  // 第一个位置元素重复
  if (i > 0 && inNums[i] == inNums[i - 1]) {
  	continue
  }
  
  // 第二个位置元素重复
  while (pL < pR && inNums[pL + 1] == inNums[pL]) {
  	pL++;
  }
  
  // 第三个位置元素重复
  while (pL < pR && inNums[pR - 1] == inNums[pR]) {
  	pR--;
  }
  ```

  - 这是一个有顺序的问题，可以使用双指针加快查找。假设指向第二个元素的位置为左指针L = i +1，指向第三个元素的位置为右边指针R = len -1，开启第二重循环；
    - 当num[i] + num[L] + num[R] = 0，找到一组结果。继续执行判断左界和右界是否和他们的下一位置重复。如果重复则跳过直到不重复。但L和R没有重复时，同时将L，R 移到下一位置，寻找新的解。
    - 若num[i] + num[L] + num[R] > 0，说明 num[R]太大，只需R左移；
    - 若num[i] + num[L] + num[R] < 0，说明 num[L]太小，只需L右移；

**源码：**/java_pro/  threeSum()

**关键字：**排序，==双指针==，==重复跳过==

# 寻找众数

**投票方法思路理解：**

- 如果候选人不是major，则真正的major会和其他非候选人一起反对当前候选人(count减少)，那么当前候选人最终一定会下台(count==0时发生换届选举)；
- 如果候选人是major , 则major会支持自己(count增加)，虽然其他候选人会反对，但因为major票数超过一半，所以最终major一定会成功当选。即最终candidate一定是major。

```c
if (count == 0) {// 候选人换届
	candidate = num;
}
/**
* 候选人被支持(num == candidate)，count增加
* 候选人被反对(num != candidate),count减少
**/
count += (num == candidate) ? 1 : -1;
```

**源码：**/cpp_pro/array/   majorElement2()

**关键词：**==投票==，==支持/反对==，==换届==

# 缺失的第一个正整数

**思路理解：**

- 明白第一个正整数x的特性，x一定落在[1,n+1]之间。
- 利用现有数组空间，稍加改造成hashmap，方便快速查找。
- 既要标记位置，又要保留位置上的数值，因此这里采用改变符号来实现。

**源码：**/java_pro/  firstMissingPositive()

**关键词：**数组改造hashmap、改变符号来标记、排除负数影响

# 链表是否有环

**快慢指针思路理解：**

- 有环快慢指针一定相遇；
- 初始条件slow = head，fast = head->nex，可以理解为在head之前有一个虚拟节点，且初始条件是两个节点分别按照自己的步长走了一次;
- 注意快指针的非空判定；

```c
if (fast == nullptr || fast->next == nullptr) {
    return false;
}
```

- 快指针每移动一步，就可以判定是否与满指针相遇，这样便于快速判定是否有环。

```c
slow = slow->next;
fast = fast->next;
if (fast != nullptr && slow == fast) {
    return true;
}
```

**源码：**/cpp_pro/linked_list/   has_circle()

**关键字：**==快慢指针==

# 合并k个排序链表

**思路关键：**

- 方法都依赖于合并两个有序链表
- 方法二的递归，注意结束条件：

```c
if (left == right) return lists[left];
if (left > right) return nullptr;
```

**源码：**/cpp_pro/linked_list/  merge_k_sorted_linked_list_1()/merge_k_sorted_linked_list_2()

**关键词：**两个有序链表合并、两两合并逐步减少量

# 数组实现栈

**核心要点：**

- ==索引0作为栈底==
- ==栈顶top指向的是待入栈的位置==
- 空栈：top = 0
- 满栈：top = size

**代码：**/cpp_pro/stack/ ArrayStack 

# 链表实现栈

**核心要点：**

- 链表头作为栈底，==链表尾部作为栈顶，栈顶top指向栈顶元素，且需要确保栈底元素的next指针为nullptr==
- 没有满栈之说，只有空栈问题
- 空栈：top = nullptr

**代码：**/cpp_pro/stack/ LinkedListStack

# 数组实现队列

**核心要点：**

- ==索引0作为对头==
- ==对头索引head指向对头元素，队尾索引tail指向的是下一个待入队的位置==
- 空队：head == tail
- 满队：tail == size && head == 0
- 只有当tail == size，再触发是否需要移动队列前部分的元素：

```c
if (tail == size) {
    ……
    /**
     * move array's valid element to head only when tail grow up to size
     */
    for (int i = head; i < tail; ++i) {
        items[i - head] = item[i];
    }
    tail -= head;
    head = 0;
}
```

**代码：**/cpp_pro/queue/ ArrayQueue

# 链表实现队列

**核心要点：**

- ==链表头作为对头，链表尾作为队尾==

- ==head指向对头元素，tail指向队尾元素==

- 没有满对之说，只有空队问题

- 队空：head == nullptr

- 入队：

  - 首先将待入队元素的next指向nullptr

  - 如果head == nullptr，表示此时队空，对头head和队尾tail都指向入队元素

  - 否则只需要把当前队尾元素的next指向待入队元素，并移动队尾

    ```c
    // 先将待入队元素的next指向nullptr
    item->next = nullptr;
    if (head == nullptr) {// 队列为空
        head = item;
        tail = item;
        return true;
    }
    // 队列不为空，正常入队
    tail->next = item;
    tail = item;
    return true;
    ```

- 出队：

  - 如果队列为空，直接返回nullptr
  - 否则正常将head指向的元素返回（注意在返回之前，将该元素的next指向nullptr），并将head指针后移一位(此时可以检查移动后的head是否为空，如果为空表示队列已经空，可以顺带将tail = nullptr)

  ```c
  linked_list::node<T> *LinkedListQueue<T>::dequeue() {
    	// 先判定队列是否为空
      if (head == nullptr) {
          return nullptr;
      }
    	// 不为空正常出队
      linked_list::node<T> *item = head;
      head = head->next;
      if (head == nullptr) {// 出队后再看看队列是否已经为空
          tail = nullptr;
      }
    	// 返回之前一定要记得把next指向nullptr,切断连接
      item->next = nullptr;
      return item;
  }
  ```


**代码：**/cpp_pro/queue/ LinkedListQueue

# 数组实现循环队列

**核心要点:**

- 当数组静态时tail指向下一个待入队的位置，且始终空出来(哪怕在判断队满的情况下，tail位置也是空的，循环队列会浪费一个数组的存储空间)
- 队满：(tail + 1) % capacity == head 队尾移动一个位置就达到对头
- 队空：head == tail 队头与队尾指向同一个位置

**代码：**/cpp_pro/queue/ ArrayCircleQueue 

# 递归

**递归需要满足的三个条件：**

1. 一个问题的解可以分解为几个子问题的解
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
3. 存在递归终止条件

**编写递归代码核心点：**

- 写出递推公式
- 找到终止条件

思考方向是从==n->有限数据==

**递归转换为迭代：**

由于递归采用的是栈思想，理论上所有递归都可以使用迭代实现

- 对于特殊有限数据求值
- 写出递归公式，并从有限数据循环迭代到无限数据n

思考方向从==有限数据->n==

# 有效的括号

**核心要点：**

- 使用map来事先存储括号对
- 重点关注发现的右括号：发现了一个右括号，就得从栈顶出一个左括号与之匹配，否则直接返回无效(false)
- 只要不是有括号，就入栈
- 最后再检查栈是否为空
- 事先通过字符串中字符数量的奇偶性来判定，有效括号对必然是不为空且是偶数。

**源码：**/cpp_pro/stack/ brackets_is_valid()

# 最长有效括号

**栈算法核心要点：**

- 栈中（除了栈底）存放的是左右括号的索引；
- ==第一个不匹配==的右括号作为分隔点，将其索引放入栈底；
- 为了适配第一符号就是右边括号，直接在提前在栈底放入-1，可以假设在索引0之前放入了一个分隔符(也就是右边括号)
- 遇到左括号自己接入栈，遇到右括号就从栈顶开始匹配；

**源码：**/cpp_pro/stack/ longest_valid_parentheses_2()

------

**左右计数器算法核心思想：**

- 先从左往右边来看，使用两个计数器left、right来记录左右括号出现的次数。当left == right相等时，表明出现了能匹配的成对括号。当right > left时出现了第一个不匹配的右边括号(与栈算法类似，将不匹配的右括号作为分隔符)，此时将left、right归零重新计算；
- 一定记得既要从左到右遍历，也要从右往左遍历，这样才能包括完全。在从右往左遍历时的判断条件与从左往右正好相反，将不匹配的左括号作为分隔符。

**源码：**/cpp_pro/stack/ longest_valid_parentheses_3()

# 滑动窗口最大值

**大顶堆解法核心要点：**

- 从一堆数中取出最大值，大顶堆这种数据结构，正好满足
- 每次从大顶堆中取出元素确保它落在滑动窗口内，不然就移除堆顶元素直到满足：

```c
/**
* in case the top is out of window
*/
while (!max_top_heap.empty() && max_top_heap.top().second <= i - k) {
	max_top_heap.pop();
}
```

**源码：**/cpp_pro/queue/ max_sliding_window1()

------

**单调递减双端队列核心要点：**

- 前置条件是想到维护一个元素大小单调递减，索引值单调递增的队列(其实只需要在队列中保存元素的索引值即可)，队列中的元素才可能是某个滑动窗口的最大值，证明见解题思路leetcode——反证法
- 每次新进元素都必须与队尾元素比较，确保队列单调递减，否则就不断从队尾“弹”出元素直到满足；

```c
/**
* be sure the descending_q is descending
*/
while (!descending_q.empty() && nums[i] >= nums[descending_q.back()]) {
	descending_q.pop_back();
}
descending_q.push_back(i);
```

- 某个窗口的最大值只可能出现在队头

```c
result.push_back(nums[descending_q.front()]);
```

- 每次取出对头元素后也要确保它落在窗口内，否则就不断从对头“弹”出元素直到满足。

```c
/**
* in case the top is out of window
*/
while (descending_q.front() <= i - k) {
	descending_q.pop_front();
}
```

**源码：**/cpp_pro/queue/ max_sliding_window2()

# 二叉搜索树(BST)

[二叉搜索树](https://time.geekbang.org/column/article/68334)

**核心点：**

- 难点在于二叉搜索树的删除节点，需要考虑三种类情况：待删除节点没有子节点、待删除节点最多只有一个子节点、待删除节点有两个子节点。

**源码：**/cpp_pro/tree/ BinarySearchTree 

# 二叉树

二叉树的前、中、后序遍历，按层遍

**核心知识点：**

难点是前中后序遍历的迭代法

**源码：**/cpp_pro/tree/ CommonBinaryTree

