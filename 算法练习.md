# 链表反转

**源码：**/cpp_pro/linked_list/  reverse_iterate()

# 合并两个有序链表

**源码：**/cpp_pro/linked_list/  merge_sorted_linked_list()

# 合并两个有序数组

**方法三思路关键点**：

- 每个数组都是有序的，因此比较后每个数组都是从后往前==依次==移动元素的，所以不会存在数组1中的元素被覆盖的情况(因为极端情况就是数组2都移动到数组1后面了，数组1的元素还没移动过)。
- 代码中注意每次移动了元素的数组下标才递减，没有元素移动的数组下表则不变：

```c
// 错误示例
for (int i = n - 1, j = m - 1; i >= 0 && j >= 0; i--,j--) {// 每次移动元素，两个数组的下标都递减，错误！！！
    if (i >= 0 && j >= 0) {// array1 and array2 have element to compare and move
        if (array1[i] >= array2[j]) {
            array1[--sum] = array1[i];
            
        } else {
            array1[--sum] = array2[j];
            
        }
    } else if (i >= 0) {// just remain array1 element to move
        array1[--sum] = array1[i];
        
    } else if (j >= 0) {// just remain array2 element to move
        array1[--sum] = array2[j];
        
    }
}

// 正确示例
for (int i = n - 1, j = m - 1; i >= 0 && j >= 0;) {
    if (i >= 0 && j >= 0) {// array1 and array2 have element to compare and move
        if (array1[i] >= array2[j]) {
            array1[--sum] = array1[i];
            i--;// 每次只有移动了元素的数组下标递减
        } else {
            array1[--sum] = array2[j];
            j--;// 每次只有移动了元素的数组下标递减
        }
    } else if (i >= 0) {// just remain array1 element to move
        array1[--sum] = array1[i];
        i--;// 每次只有移动了元素的数组下标递减
    } else if (j >= 0) {// just remain array2 element to move
        array1[--sum] = array2[j];
        j--;// 每次只有移动了元素的数组下标递减
    }
}
```

**源码：**/cpp_pro/array/  mergeSortedArray()

# 寻找链表中间节点

**方法三思路关键点：**

- 列表至少需要遍历一次，这一步是无论如何也避免不了的。
- 那思考可否在遍历一次就能找到中间点，这里巧妙地利用==双指针==，并根据每次==步长==的关系(1:2)，在一次遍历中就找到中间节点。拓展思考，有的场景可以利用多指针，调整步比例来解决其他问题。
- 注意结束条件，由于快指针步长为2(主要考虑列表元素长度对2取模的余数)，所以结束条件应该是2中情况。或者从如下的快指针的赋值语句来判定：首先确保p_two_step != nullptr，然后再确定p_two_step->next !=nullptr。

```c
// 此处要使用p_two_step来取值，所以首先应保证p_two_step不为空，因此应保持如下代码的&语句的顺序
while (p_two_step != nullptr && p_two_step->next != nullptr) {
	p_one_step = p_one_step->next;
	p_two_step = p_two_step->next->next;
}
```

**源码：**/cpp_pro/linked_list/  find_mid_node()

**关键词语：**==循环、步长==

# 三个数之和

**思路关键点：**

难点在于如何去除重复解

**算法流程：**

- 边界条件，数组长度为len，如果数组为null或者数组长度小于3，直接返回空。

- 对数组做升序排序

- 第一重循环开始遍历数组：

  - 若num[i] > 0，直接返回结果。因为数组已经排序过，从i开始后续再无可能三数之和等于0；
  - 对于重复元素，考虑三个位置：第一数、第二个数和第三个数。这三个位置遇到重复元素都直接跳过，只需使用一次重复元素即可

  ```java
  // 第一个位置元素重复
  if (i > 0 && inNums[i] == inNums[i - 1]) {
  	continue
  }
  
  // 第二个位置元素重复
  while (pL < pR && inNums[pL + 1] == inNums[pL]) {
  	pL++;
  }
  
  // 第三个位置元素重复
  while (pL < pR && inNums[pR - 1] == inNums[pR]) {
  	pR--;
  }
  ```

  - 这是一个有顺序的问题，可以使用双指针加快查找。假设指向第二个元素的位置为左指针L = i +1，指向第三个元素的位置为右边指针R = len -1，开启第二重循环；
    - 当num[i] + num[L] + num[R] = 0，找到一组结果。继续执行判断左界和右界是否和他们的下一位置重复。如果重复则跳过直到不重复。但L和R没有重复时，同时将L，R 移到下一位置，寻找新的解。
    - 若num[i] + num[L] + num[R] > 0，说明 num[R]太大，只需R左移；
    - 若num[i] + num[L] + num[R] < 0，说明 num[L]太小，只需L右移；

**源码：**/java_pro/  threeSum()

**关键字：**排序，==双指针==，==重复跳过==

# 寻找众数

**投票方法思路理解：**

- 如果候选人不是major，则真正的major会和其他非候选人一起反对当前候选人(count减少)，那么当前候选人最终一定会下台(count==0时发生换届选举)；
- 如果候选人是major , 则major会支持自己(count增加)，虽然其他候选人会反对，但因为major票数超过一半，所以最终major一定会成功当选。即最终candidate一定是major。

```c
if (count == 0) {// 候选人换届
	candidate = num;
}
/**
* 候选人被支持(num == candidate)，count增加
* 候选人被反对(num != candidate),count减少
**/
count += (num == candidate) ? 1 : -1;
```

**源码：**/cpp_pro/array/   majorElement2()

**关键词：**==投票==，==支持/反对==，==换届==
